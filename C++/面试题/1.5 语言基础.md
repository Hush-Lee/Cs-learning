> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.nowcoder.com](https://www.nowcoder.com/study/live/690/2/5)

> 牛客网是 IT 求职神器, 国内一流互联网公司面试中常见的算法题及考察点系统讲解，帮大家系统梳理面试所需要的算法知识，提高刷题效率，轻松搞定算法面试。

#### 1.1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景

**参考回答**

1.  **首先从作用域考虑**：C++ 里作用域可分为 6 种：全局，局部，类，语句，命名空间和文件作用域。
    
    全局变量：全局作用域，可以通过 extern 作用于其他非定义的源文件。
    
    静态全局变量 ：全局作用域 + 文件作用域，所以无法在其他文件中使用。
    
    局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。
    
    静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。
    
2.  **从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。
    
3.  **生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。
    
4.  **使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。
    

#### 1.1.15 说说内联函数和宏函数的区别

**参考回答**

区别：

1.  **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；**而内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。
2.  **宏函数**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；**而内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率
3.  **宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等

**答案解析**

```
//宏定义示例
#define MAX(a, b) ((a)>(b)?(a):(b))
MAX(a,"Hello")； //错误地比较int和字符串，没有参数类型检查

//内联函数示例
#include <stdio.h>
inline int add(int a, int b){
    return (a + b);
}
int main(void){
    int a;
    a = add(1, 2);
    printf("a+b=%d\n", a);
    return 0;
}
//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);

```

**1、使用时的一些注意事项：**

*   使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性
*   inline 函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字 inline，即可将函数指定为 inline 函数。
*   同其它函数不同的是，最好将 inline 函数定义在头文件，而不仅仅是声明，因为编译器在处理 inline 函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。

**2、内联函数使用的条件：**

*   内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：
*   （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
*   （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
*   内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。

#### 1.1.16 说说运算符 i++ 和 ++i 的区别

**参考回答**

**先看到实现代码：**

```
#include <stdio.h>
int main(){
       int i = 2;
    int j = 2;
    j += i++; //先赋值后加
    printf("i= %d, j= %d\n",i, j); //i= 3, j= 4
    i = 2;
    j = 2;
    j += ++i; //先加后赋值
    printf("i= %d, j= %d",i, j); //i= 3, j= 5
}

```

1.  **赋值顺序不同**：++ i 是先加后赋值；i ++ 是先赋值后加；++i 和 i++ 都是分两步完成的。
    
2.  **效率不同**：后置 ++ 执行速度比前置的慢。
    
3.  **i++ 不能作为左值，而 ++i 可以**：
    
    ```
    int i = 0;
    int *p1 = &(++i);//正确
    int *p2 = &(i++);//错误
    ++i = 1; //正确
    i++ = 1; //错误
    
    ```
    
4.  两者都不是原子操作。
    

#### 1.1.17 说说 new 和 malloc 的区别，各自底层实现原理。

**参考回答**

1.  new 是操作符，而 malloc 是函数。
2.  new 在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而 malloc 没有构造函数和析构函数。
3.  malloc 需要给定申请内存的大小，返回的指针需要强转；new 会调用构造函数，不用指定内存的大小，返回指针不用强转。
4.  new 可以被重载；malloc 不行
5.  new 分配内存更直接和安全。
6.  new 发生错误抛出异常，malloc 返回 null

**答案解析**

**malloc 底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用 mmap（）。malloc 采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

**new 底层实现：**关键字 new 在调用构造函数的时候实际上进行了如下的几个步骤：

1.  创建一个新的对象
2.  将构造函数的作用域赋值给这个新的对象（因此 this 指向了这个新的对象）
3.  执行构造函数中的代码（为这个新对象添加属性）
4.  返回新对象

#### 1.1.18 说说 const 和 define 的区别。

**参考回答**

const 用于定义常量；而 define 用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：

1.  const 生效于编译的阶段；define 生效于预处理阶段。
2.  const 定义的常量，在 C 语言中是存储在内存中、需要额外的内存空间的；define 定义的常量，运行时是直接的操作数，并不会存放在内存中。
3.  const 定义的常量是带类型的；define 定义的常量不带类型。因此 define 定义的常量不利于类型检查。